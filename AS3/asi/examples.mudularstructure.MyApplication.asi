package examples.mudularstructure
{
	import examples.helloflash.HelloFlash;
	import examples.helloworld.MainHelloWorld;
	import org.bixbite.core.Compound;
	import org.bixbite.framework.modules.stats.Stats;

	/**
	 *
	 * @version compatibility 0.5.1
	 * @since 0.4.3
	 *   total footprint 10.7kb
	 *   
	 *     Purpose of this example is to show you true power of BixBite framework.
	 *   Due to architecture arrangement, Crystal pattern and Signal/Slot system that keeps all classes perfectly decoupled, let you create number of small functional applications (Compounds) and put them together in no time, to create brand new application.
	 *   This is very powerful feature. To addition to high-performance structure you can very quickly build entire application from early developed small applications and run them all at once as modules.
	 *   Then, this class become main application that will be a bridge between functional modules. 
	 *   Going further, you can create another one app when this one will become a module!
	 *   
	 *     NAMS - Nested Application Modular System
	 *   
	 *     We going to use all previously developed examples.
	 */
	public class MyApplication extends Compound
	{
		public function MyApplication ();

		/**
		 * Now, this is something worth consideration. Each functional Compound might have some public methods exposed to control internal functional modules.
		 * This way you can easily provide some API for your modules, than can be controlled from main Compound/Application directly.
		 * However indirectly you can still use Signals to even keep your modules decoupled!
		 * 
		 *   BixBite framework assuming this is perfectly fine to use both ways in this case.
		 * You need to consider yourself what better suits you for development purposes.
		 */
		public function exposedModuleMethod () : void;
	}
}
