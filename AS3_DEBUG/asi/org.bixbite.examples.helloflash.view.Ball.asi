package org.bixbite.examples.helloflash.view
{
	import flash.display.Sprite;
	import org.bixbite.core.interfaces.ISignal;
	import org.bixbite.examples.helloflash.signal.BallSignal;
	import org.bixbite.framework.view.DisplayView;

	/**
	 *
	 * @version  compatibility - 0.4.1
	 */
	public class Ball extends DisplayView
	{
		private var component : Sprite;
		private var radius : int;
		private var color : uint;

		/**
		 * We using Decorator Pattern to deal with native DisplayObjects, is up to you what you will expose to the application interface.
		 * Do you need to know rotationZ or hitArea of this bit in our example? I don't think so... View by Decoration automatically becomes mediator of this element, but has nothing to do with any kind of logic.
		 */
		public function get x () : Number;
		public function set x (value:Number) : void;

		public function get y () : Number;
		public function set y (value:Number) : void;

		/**
		 * Constructor
		 */
		public function Ball ();

		public function init () : void;

		private function onMakeBallRed (s:ISignal) : void;

		/**
		 * Wee will stick to RL implementation of this bit, but having Proper Model in place we should redraw this view with already known values provided by signal.
		 * View should not perform any calucaltions!
		 * @param	s signal recieved from ... view should not care at all.
		 */
		private function shuffle (s:ISignal) : void;

		/**
		 * Notice, we using already Classic version of framework. By using DisplayView graphics are already exposed, so you don't have to operate directly on component.
		 * This is because graphics will be consistent across many diferent branches. It means, unified way to draw stuff regardless of its implementation. Bitmap Blitting, Custom Display List or even Stage3D.
		 */
		private function draw (color:uint, radius:int) : void;
	}
}
