<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8"/>
	<title>BixBite</title>
	<meta name="description" content="" />
	
	<script src="js/core/bixbite.js"></script>
	
	<style>
		html, body { height:100%; overflow:hidden; }
		body { margin:0; }
	</style>
</head>

<body>
	<script>
		
		/*
		BixBite framework exposes very few Classes/Components on the global scope ready to work with and extend your own classes from.
		It is very shallow and strict structure, deal with it as a set of reserved words:
		
		BixBite 	- main Class, in order to initialise framework you need to create one instance of this Class.
		
		Behaviour	- executable component with an extra method execute() to leverage business logic;
		Compound	- functional module
		Data		- data component
		Transponder	- transponder component
		View		- view component
		
		There are also some helper methods available on the global scope:
		
		trace();
		getTimer();
		
		From now on all classes you are going to write should extend those components above and have one method implemented within, init();
		For instance:
		
		MyCompound.extend(Compound);
		function MyCompound(){
			this.init=function(){
				//trace(MyCompound has been initialised);
			}
		}
		
		It is recomended that Behaviour,Data,Transponder and View class definitions are writen inside Compound body to prevent exposing them into global scope.
		
		For instance:
		MyCompound.extend(Compound);
		function MyCompound(){
			this.init=function(){
				//trace(MyCompound has been initialised);
				this.register(MyView);
			}
			
			MyView.extend(View);
			function MyView(){
				this.init=function(){
					//trace(MyView is up);
				}
			}
		}
		
		In BixBite framework you don't have to worry about JS scope issues.
		if you adding slots and recieving signals or dealing with native events 'this' always refers to the Class you are in.
		
		For instance:
		
		MyView.extend(View);
		function MyView(){
			this.init=function(){
				addSlot("test", onTest);
			}
			
			onTest = function(signal){
				trace(this);//output MyView
			}
		}
		*/
		
		// Here is some Compound(Functional Module) definition with internal Components
		// In this example we testing View with an Context
		MyCompound.extend(Compound);
		function MyCompound(){
			
			this.init=function(){
				this.register(MyView);
			}
			
			MyView.extend(View);
			function MyView(){
				
				this.init=function(){
					
					var root = this.getContainer("root");
					
					var context = new Context();
					context.graphics.beginFill(0xFF0000,1);
					context.graphics.drawRect(0,0,100,100);
					this.registerContext("test", context);
					root.addChild(context);
				}
			}
		}
		
		//This is a typical code block to initialise BixBite:
		//Create Instance of BixBite
		var t = getTimer();
		
		var bb = new BixBite();
		//Add a root for DOM displayable elements (it can be any div)
		//bb.addContextRoot("stage", document.body);
		//Spawn a core(You can spawn multiple cores and register diferent Compounds within them)
		var core = bb.spawnCore("main");
		//Register previusly created Compound
		core.register(MyCompound);
		
		trace("time:", getTimer()-t);
		//Compound can start itself if you have some auto executable Behaviours or you can always kick start them with some custom signal
		//core.emitSignal("kick")
		//It is usefull if you need to pass some initial parameters to your functional Module/Compound
		//core.emitSignal("kick", {delay:100});
		
	</script>
</body>

</html>